
<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Captura de Góndolas</title>
  <style>
    body{margin:0;background:#0f172a;color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto}
    .wrap{max-width:720px;margin:0 auto;padding:16px}
    .card{background:#0b1220;border:1px solid #202a44;border-radius:16px;padding:16px}
    label{display:block;font-size:14px;color:#94a3b8;margin:8px 0 6px}
    input{width:100%;padding:12px 14px;border-radius:12px;border:1px solid #29324c;background:#0e1629;color:#e5e7eb;font-size:16px}
    button{border:0;background:#2563eb;color:white;border-radius:12px;padding:10px 12px;font-size:14px;font-weight:600;cursor:pointer}
    button.secondary{background:#334155}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    .status{margin-top:12px;font-size:14px;color:#94a3b8}
    #gallery{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:12px}
    .thumb{position:relative;border:1px solid #223;border-radius:10px;overflow:hidden}
    .thumb img{width:100%;display:block}
    .thumb button{position:absolute;top:4px;right:4px;background:#1f2937;color:#fff;border:0;border-radius:8px;padding:4px 6px;cursor:pointer}

    /* ===== Overlay 4:3 + rejilla ===== */
    .videoWrap{position:relative;border-radius:16px;overflow:hidden;border:1px solid #223;background:black}
    .videoWrap[data-ar="4:3"]{aspect-ratio:4/3;}
    .videoWrap video{width:100%;height:100%;object-fit:cover;display:block}
    .overlay{
      position:absolute; inset:0; pointer-events:none; border-radius:16px;
      box-shadow: inset 0 0 0 2px rgba(255,255,255,.15);
      background:
        linear-gradient(rgba(255,255,255,.18), rgba(255,255,255,.18)) 33.333% 0 / 1px 100% no-repeat,
        linear-gradient(rgba(255,255,255,.18), rgba(255,255,255,.18)) 66.666% 0 / 1px 100% no-repeat,
        linear-gradient(rgba(255,255,255,.18), rgba(255,255,255,.18)) 0 33.333% / 100% 1px no-repeat,
        linear-gradient(rgba(255,255,255,.18), rgba(255,255,255,.18)) 0 66.666% / 100% 1px no-repeat;
      outline: 800px solid rgba(0,0,0,.0);
    }

    /* ===== Botón flotante de captura y flash ===== */
    .fab{
      position:absolute; left:50%; transform:translateX(-50%);
      bottom: max(12px, env(safe-area-inset-bottom) + 12px);
      width:68px; height:68px; border-radius:50%;
      background:#ffffff; color:#0b1220; border:0;
      box-shadow:0 6px 20px rgba(0,0,0,.35), inset 0 0 0 2px rgba(11,18,32,.6);
      display:grid; place-items:center; cursor:pointer; transition:transform .05s ease;
    }
    .fab:active{ transform:translateX(-50%) scale(0.96) }
    .flash{ position:absolute; inset:0; pointer-events:none; border-radius:16px; background:#fff; opacity:0 }
    .flash.on{ animation: flashBlink 140ms ease-in-out forwards }
    @keyframes flashBlink{ 0%{opacity:.9} 100%{opacity:0} }

    /* ===== Controles de zoom ===== */
    .zoomBar{display:flex;align-items:center;gap:10px;margin-top:8px}
    .zoomBar input[type="range"]{width:100%}
    .zoomBar .tag{font-size:12px;color:#a3bffa}

    .build{font-size:12px;color:#60a5fa;margin-bottom:8px}
    .diag{margin-top:14px;background:#0a1222;border:1px dashed #2a365a;border-radius:12px;padding:12px}
    .diag h3{margin:0 0 8px 0;font-size:14px;color:#a3bffa}
    .diag pre{white-space:pre-wrap;word-wrap:break-word;background:#0a1329;border:1px solid #1d2847;border-radius:8px;padding:10px;max-height:220px;overflow:auto}
  </style>
</head>
<body>
<div class="wrap"><div class="card">
  <div class="build">v2-diag — overlay 4:3 + zoom — botón flotante + auto-add</div>
  <h1>Captura de Góndolas</h1>

  <label>Usuario</label>
  <input id="user" autocomplete="username" />
  <label>Contraseña</label>
  <input id="pass" type="password" autocomplete="current-password" />
  <label>N° de sala</label>
  <input id="room" type="text" inputmode="text" autocapitalize="characters" autocomplete="off" spellcheck="false" maxlength="20" placeholder="ej: A01" />

  <div class="row" style="margin-top:8px">
    <button id="btnStart" onclick="startCamera()">Iniciar cámara</button>
    <button id="btnCapture" class="secondary" disabled onclick="capture()">Capturar</button>
    <!-- Agregar foto ya no se usa: auto-add tras capturar -->
    <button id="btnAddPhoto" class="secondary" style="display:none">Agregar foto</button>
  </div>

  <!-- Video + Overlay 4:3 + canvas oculto + botón flotante + flash -->
  <div class="videoWrap" data-ar="4:3">
    <video id="camera" autoplay playsinline muted></video>
    <canvas id="snapshot" style="display:none"></canvas>

    <!-- Botón flotante (ícono de cámara) -->
    <button id="btnShutter" class="fab" aria-label="Capturar" onclick="capture()">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" aria-hidden="true">
        <path d="M9 4l1.5-2h3L15 4h3a3 3 0 013 3v9a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h3z" stroke="#0b1220" stroke-width="1.5" fill="#fff"/>
        <circle cx="12" cy="12" r="3.5" fill="#0b1220"/>
        <circle cx="12" cy="12" r="2.5" fill="#fff"/>
      </svg>
    </button>

    <!-- Flash -->
    <div id="flash" class="flash" aria-hidden="true"></div>

    <!-- Rejilla -->
    <div class="overlay"></div>
  </div>

  <!-- Barra de zoom -->
  <div class="zoomBar" id="zoomBar" hidden>
    <span class="tag">Zoom</span>
    <input type="range" id="zoom" min="1" max="1" step="0.1" value="1" />
    <span id="zoomVal" class="tag">1.0×</span>
  </div>

  <div class="row" style="margin-top:10px">
    <button id="btnRetake" class="secondary" disabled onclick="retake()">Repetir</button>
    <button id="btnSendBatch" onclick="(async()=>{await buildAndStageBatches();status('Enviando lote…');await sendOutboxWithRetry();triggerBGSync();})()">Enviar lote</button>
    <button id="btnRetry" class="secondary" onclick="sendOutboxWithRetry()">Reintentar ahora</button>
    <button id="btnTestAuth" class="secondary" onclick="testAuth()">Probar credenciales</button>
  </div>

  <!-- Galería -->
  <div id="gallery"></div>

  <div class="status"><span id="msg">Listo</span><br/><span id="queueMsg">Cola: 0 fotos pendientes | Lotes en envío: 0</span></div>

  <!-- Diagnóstico -->
  <div class="diag">
    <h3>Diagnóstico</h3>
    <div class="row">
      <button class="secondary" onclick="showOutbox()">Ver outbox</button>
      <button class="secondary" onclick="forceUpdate()">Forzar actualización (limpiar SW/Cache)</button>
    </div>
    <pre id="log"></pre>
  </div>
</div></div>

<script>
/* ========== Config ========== */
const FLOW_UPLOAD_URL = "https://defaultab52009f566c40d1940686e6a61980.d1.environment.api.powerplatform.com:443/powerautomate/automations/direct/workflows/51a6e085ab6f40338b007d0b0925eaa9/triggers/manual/paths/invoke?api-version=1&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=XRRtlLgS7mtHs9PjkE64NpUyuvbDQXUoe9rP1VawKsc";
const MAX_DIM = 1600, JPEG_QUALITY = 0.82;
const BATCH_MAX_IMAGES = 5;
const RETRY_BASE_MS = 2000, RETRY_MAX_MS = 60000;

/* ========== Estado/UI ========== */
const $user = document.getElementById('user');
const $pass = document.getElementById('pass');
const $room = document.getElementById('room');
const $video = document.getElementById('camera');
const $zoomBar = document.getElementById('zoomBar');
const $zoom = document.getElementById('zoom');
const $zoomVal = document.getElementById('zoomVal');
const $btnCapture = document.getElementById('btnCapture');
const $btnRetake = document.getElementById('btnRetake');
const $btnAddPhoto = document.getElementById('btnAddPhoto');
const $btnSendBatch = document.getElementById('btnSendBatch');
const $gallery = document.getElementById('gallery');
const $queueMsg = document.getElementById('queueMsg');
const $msg = document.getElementById('msg');
const $log = document.getElementById('log');
let stream=null, photoReady=false, currentJpegB64=null;

function status(t, ok=true){ $msg.textContent=t; $msg.style.color=ok?'#a7f3d0':'#fecaca'; log(t); }
function log(...args){ const s = args.map(a=> typeof a==='string'? a : JSON.stringify(a)).join(' '); $log.textContent += (s+'\n'); $log.scrollTop = $log.scrollHeight; }
function normalizeRoom(v){ return (v || "").toUpperCase().trim().replace(/\s+/g,''); }
function isValidRoom(v){ return /^[A-Z0-9-]{1,20}$/.test(v); }

/* ======== Feedback de captura ======== */
let __ac; // AudioContext
async function playShutterSound(){
  try{
    __ac = __ac || new (window.AudioContext || window.webkitAudioContext)();
    if (__ac.state === 'suspended') { await __ac.resume(); }
    const o = __ac.createOscillator();
    const g = __ac.createGain();
    o.type = 'square';
    o.frequency.setValueAtTime(980, __ac.currentTime);
    o.frequency.exponentialRampToValueAtTime(440, __ac.currentTime + 0.06);
    g.gain.setValueAtTime(0.0001, __ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, __ac.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, __ac.currentTime + 0.09);
    o.connect(g).connect(__ac.destination);
    o.start(); o.stop(__ac.currentTime + 0.10);
  }catch(e){ /* iOS en silencio puede bloquear: ignorar */ }
}
function triggerFlash(){
  const el = document.getElementById('flash'); if(!el) return;
  el.classList.remove('on'); void el.offsetWidth; el.classList.add('on');
}

/* ========== Cámara + ZOOM ========== */
async function startCamera(){
  if(!$user.value || !$pass.value || !isValidRoom(normalizeRoom($room.value))){
    status('Complete usuario/clave y sala válida', false); return;
  }
  try { if (stream) stream.getTracks().forEach(t=>t.stop()); } catch {}

  const explain = (err) => {
    if (!err || !err.name) return `Error desconocido al iniciar cámara`;
    switch (err.name) {
      case 'NotAllowedError':
      case 'SecurityError': return 'Acceso a la cámara bloqueado. Habilítalo en el candado del navegador y recarga.';
      case 'NotFoundError': return 'No se encontró ninguna cámara.';
      case 'NotReadableError': return 'La cámara está en uso por otra aplicación.';
      case 'OverconstrainedError': return 'La cámara no soporta estas restricciones. Probando alternativas…';
      default: return `${err.name}: ${err.message||''}`.trim();
    }
  };

  const trials = [
    { video: { facingMode:{ideal:'environment'}, width:{ideal:1920}, height:{ideal:1080} }, audio:false },
    { video: { facingMode:{ideal:'environment'} }, audio:false },
    { video: true, audio:false }
  ];

  let lastErr=null;
  for(const c of trials){
    try{
      status('Iniciando cámara…');
      stream = await navigator.mediaDevices.getUserMedia(c);
      $video.srcObject = stream; try{ await $video.play(); }catch{}
      await new Promise(res=>{ const tid=setTimeout(res,1200); $video.onloadedmetadata=()=>{clearTimeout(tid);res();}; });
      if (!$video.videoWidth || !$video.videoHeight) throw new Error('Video sin dimensiones');
      $btnCapture.disabled=false; status('Cámara lista');
      setupZoomUI(stream);
      return;
    }catch(e){ lastErr=e; status(explain(e), false); }
  }
  status(`No se pudo acceder a la cámara. ${explain(lastErr)}`, false);
}

function setupZoomUI(stream){
  const track = stream.getVideoTracks()[0];
  const caps = track.getCapabilities?.() || {};
  const settings = track.getSettings?.() || {};

  if ('zoom' in caps && (typeof caps.zoom.min === 'number')) {
    $zoomBar.hidden = false;
    const min = caps.zoom.min ?? 1;
    const max = caps.zoom.max ?? 1;
    const step = caps.zoom.step || 0.1;
    const cur  = settings.zoom ?? min;
    $zoom.min = min; $zoom.max = max; $zoom.step = step; $zoom.value = cur;
    $zoomVal.textContent = `${Number(cur).toFixed(1)}×`;

    $zoom.oninput = async () => {
      const z = Number($zoom.value);
      $zoomVal.textContent = `${z.toFixed(1)}×`;
      try { await track.applyConstraints({ advanced: [{ zoom: z }] }); }
      catch(e){ log('Zoom error:', e.message); }
    };
  } else {
    $zoomBar.hidden = true; // no soporta zoom
  }
}

async function waitForVideoDims(maxTries=15, delayMs=120){
  for (let i=0; i<maxTries; i++){
    if ($video && $video.videoWidth && $video.videoHeight) return true;
    await new Promise(r => setTimeout(r, delayMs));
  }
  return !!($video && $video.videoWidth && $video.videoHeight);
}

function getOrCreateCanvas(){
  let cv = document.getElementById('snapshot');
  if (cv && cv.getContext) return cv;
  cv = document.createElement('canvas');
  cv.id = 'snapshot';
  cv.style.display = 'none';
  (document.querySelector('.videoWrap') || document.body).appendChild(cv);
  return cv;
}

async function capture(){
  try{
    status('Capturando…');

    const okDims = await waitForVideoDims(15, 120);
    const vw = $video?.videoWidth, vh = $video?.videoHeight;
    if (!okDims || !vw || !vh){ status('Cámara aún sin dimensiones válidas. Intenta nuevamente.', false); return; }

    const long = Math.max(vw, vh), scale = long > MAX_DIM ? MAX_DIM / long : 1;
    const tw = Math.round(vw * scale), th = Math.round(vh * scale);

    const canvas = getOrCreateCanvas();
    canvas.width = tw; canvas.height = th;
    const ctx = canvas.getContext('2d', { alpha:false });

    await new Promise(r => requestAnimationFrame(r));
    ctx.drawImage($video, 0, 0, tw, th);

    let dataUrl = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
    if (!dataUrl || dataUrl.length < 50){
      await new Promise(r => setTimeout(r, 120));
      ctx.drawImage($video, 0, 0, tw, th);
      dataUrl = canvas.toDataURL('image/jpeg', JPEG_QUALITY);
      if (!dataUrl || dataUrl.length < 50){ status('No se pudo capturar la imagen. Repite la captura.', false); return; }
    }

    // Feedback
    playShutterSound();
    triggerFlash();
    if (navigator.vibrate) navigator.vibrate(30);

    // Auto-add
    currentJpegB64 = dataUrl.split(',')[1];
    photoReady = true;
    await addCurrentPhotoToQueue();

    // listo para siguiente
    $btnCapture.disabled = false;
    $btnRetake.disabled  = true;
    if ($btnAddPhoto) $btnAddPhoto.disabled = true;
    status(`Foto agregada (${tw}×${th}). Lista para la siguiente.`);
  } catch(e){
    console.error('capture error', e);
    status(`Error capturando: ${e.message}`, false);
  }
}

function retake(){
  $btnCapture.disabled=false; $btnRetake.disabled=true; if($btnAddPhoto) $btnAddPhoto.disabled=true;
  photoReady=false; currentJpegB64=null; status('Repita la captura.');
}

/* ========== IndexedDB ========== */
let db;
function openDB(){
  return new Promise((resolve,reject)=>{
    const req = indexedDB.open('auditoria-gondolas-db', 1);
    req.onupgradeneeded = (e)=>{
      const db = e.target.result;
      if(!db.objectStoreNames.contains('captures')) db.createObjectStore('captures',{keyPath:'image_id'});
      if(!db.objectStoreNames.contains('outbox')) db.createObjectStore('outbox',{keyPath:'batch_id'});
      if(!db.objectStoreNames.contains('processed')) db.createObjectStore('processed',{keyPath:'image_id'});
    };
    req.onsuccess = ()=>{db=req.result; resolve(db);};
    req.onerror = ()=>reject(req.error);
  });
}
function tx(store, mode='readonly'){ return db.transaction(store, mode).objectStore(store); }
function put(store, val){ return new Promise((res,rej)=>{const r=tx(store,'readwrite').put(val); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);}); }
function del(store, key){ return new Promise((res,rej)=>{const r=tx(store,'readwrite').delete(key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);}); }
function getAll(store){ return new Promise((res,rej)=>{const r=tx(store).getAll(); r.onsuccess=()=>res(r.result||[]); r.onerror=()=>rej(r.error);}); }
const uuid = () => crypto.randomUUID ? crypto.randomUUID() : ('id-' + Date.now() + '-' + Math.random().toString(16).slice(2));

/* ========== Galería ========== */
async function refreshGallery(){
  const items = await getAll('captures');
  $gallery.innerHTML = '';
  for (const it of items){
    const d = document.createElement('div'); d.className='thumb';
    d.innerHTML = `
      <img alt="foto" src="data:image/jpeg;base64,${it.image_base64}" />
      <button title="Quitar" data-id="${it.image_id}">✕</button>
    `;
    d.querySelector('button').onclick = async (e)=>{
      await del('captures', e.target.dataset.id);
      await refreshGallery();
      await updateQueueState();
    };
    $gallery.appendChild(d);
  }
  $btnSendBatch.disabled = items.length===0;
}
async function updateQueueState(){
  const cap = await getAll('captures');
  const out = await getAll('outbox');
  $queueMsg.textContent = `Cola: ${cap.length} fotos pendientes | Lotes en envío: ${out.length}`;
}

/* ========== Flujo de agregar y enviar ========== */
async function addCurrentPhotoToQueue(){
  if(!photoReady || !currentJpegB64){ status('Capture una foto primero', false); return; }
  const image = {
    image_id: uuid(),
    room_code: normalizeRoom($room.value),
    user: $user.value.trim(),
    client_time: new Date().toISOString(),
    device: { ua:navigator.userAgent, platform:navigator.platform, lang:navigator.language },
    image_base64: currentJpegB64
  };
  try{
    await put('captures', image);
    photoReady=false; currentJpegB64=null; if($btnAddPhoto){ $btnAddPhoto.disabled=true; }
    await refreshGallery(); await updateQueueState();
    // sin mensaje adicional; capture() ya informó
  }catch(e){
    console.error('put captures error', e);
    status('No se pudo guardar en la cola (IndexedDB).', false);
  }
}

async function buildAndStageBatches(){
  const items = await getAll('captures');
  if(items.length===0) return;
  const groups = new Map();
  for (const it of items) {
    const key = `${it.user}::${it.room_code}`;
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push(it);
  }
  for (const [key, arr] of groups) {
    const [user, room_code] = key.split('::');
    for (let i=0; i<arr.length; i+=BATCH_MAX_IMAGES) {
      const chunk = arr.slice(i, i+BATCH_MAX_IMAGES);
      const batch = {
        batch_id: uuid(), room_code, user, created_at: new Date().toISOString(),
        images: chunk.map(({ image_id, image_base64, client_time, device }) => ({ image_id, image_base64, client_time, device }))
      };
      await put('outbox', batch);
      for (const it of chunk) await del('captures', it.image_id);
    }
  }
  await refreshGallery(); await updateQueueState();
}

async function sendOutboxOnce(){
  const batches = await getAll('outbox');
  for(const b of batches){
    try{
      const res = await fetch(FLOW_UPLOAD_URL, {
        method:'POST',
        headers:{ 'Content-Type':'text/plain; charset=utf-8' },
        body: JSON.stringify({
          user: $user.value.trim(),
          password: $pass.value.trim(),
          room_code: b.room_code,
          batch_id: b.batch_id,
          images: b.images
        })
      });
      const text = await res.text();
      let data; try { data = JSON.parse(text); } catch { data = { ok: res.ok, raw: text }; }
      if(res.ok && data.ok){
        const okIds = new Set((data.results || []).filter(r=>r.ok).map(r=>r.image_id));
        for (const img of b.images) if (okIds.has(img.image_id)) await put('processed',{image_id: img.image_id, ts: Date.now()});
        await del('outbox', b.batch_id);
        status(`Lote ${b.batch_id} enviado (${(data.results||[]).length} fotos).`);
      }else{
        console.error('Upload error', res.status, data);
        status(`Error HTTP ${res.status}`, false);
        throw new Error(`HTTP ${res.status}`);
      }
    }catch(e){
      console.warn('Reintento por error:', e.message);
      status(`Error enviando ${b.batch_id}. Reintento en ${Math.round(backoff/1000)}s…`, false);
    }
  }
  await updateQueueState();
}
let backoff = RETRY_BASE_MS;
async function sendOutboxWithRetry(){
  await sendOutboxOnce();
  const out = await getAll('outbox');
  if(out.length===0){ backoff = RETRY_BASE_MS; return; }
  backoff = Math.min(backoff*2, RETRY_MAX_MS);
  setTimeout(sendOutboxWithRetry, backoff);
}
async function triggerBGSync(){
  sendOutboxWithRetry();
  if('serviceWorker' in navigator && 'SyncManager' in window){
    try { const reg = await navigator.serviceWorker.ready; await reg.sync.register('sync-outbox'); } catch {}
  }
}

/* ========== Diagnóstico ========== */
async function testAuth(){
  status('Probando credenciales…');
  try{
    const res = await fetch(FLOW_UPLOAD_URL, {
      method:'POST',
      headers:{'Content-Type':'text/plain; charset=utf-8'},
      body: JSON.stringify({ user:$user.value.trim(), password:$pass.value.trim(), room_code: normalizeRoom($room.value), images: [] })
    });
    const txt = await res.text();
    log('Auth → HTTP', res.status, txt);
    if (res.status===200) status('Credenciales OK');
    else if(res.status===401) status('Credenciales incorrectas', false);
    else status(`Auth respondió HTTP ${res.status}`, false);
  }catch(e){ log('Auth error:', e.message); status('Error de red en auth', false); }
}
async function showOutbox(){ const out = await getAll('outbox'); log('Outbox:', out.length, out); }
async function forceUpdate(){
  try{
    if ('caches' in window) {
      const keys = await caches.keys();
      for (const k of keys) if (k.startsWith('gondolas-')) await caches.delete(k);
    }
    if (navigator.serviceWorker) {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
    }
    location.reload();
  }catch(e){ log('forceUpdate error:', e.message); }
}

/* ========== Init ========== */
openDB().then(()=>{ refreshGallery(); updateQueueState(); log('Conectado:', navigator.onLine); });
if('serviceWorker' in navigator){
  const base = location.pathname.endsWith('/') ? location.pathname : location.pathname.replace(/[^/]+$/, '');
  navigator.serviceWorker.register(`${base}sw.js`, { scope: base })
    .then(reg => log('SW scope:', reg.scope))
    .catch(()=>{});
}
</script>
</body>
</html>

